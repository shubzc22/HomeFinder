<!doctype html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto-start Jitsi as Moderator</title>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, sans-serif; background:#111; color:#fff; }
    #jitsi-container { width:100%; height:100vh; background:#000; display:block; }
    #overlay {
      position: fixed; right: 12px; top: 12px;
      background: rgba(0,0,0,0.5); padding:8px 10px; border-radius:8px;
      backdrop-filter: blur(4px);
      font-size:13px;
    }
    #copyBtn { margin-left:6px; cursor:pointer; padding:4px 8px; border-radius:4px; border:none; }
  </style>
</head>
<body>
  <div id="overlay">Meeting room: <span id="roomName">...</span>
    <button id="copyBtn">Copy link</button>
  </div>

  <div id="jitsi-container"></div>

  <script src="https://meet.jit.si/external_api.js"></script>
  <script>
    (function(){
      // Auto-generate a unique room name so you become the first participant (moderator)
      const roomName = 'AutoRoom-' + Date.now() + '-' + Math.floor(Math.random()*10000);
      document.getElementById('roomName').textContent = roomName;
      const domain = 'meet.jit.si';
      const container = document.getElementById('jitsi-container');

      // Copy link button (useful to share)
      document.getElementById('copyBtn').addEventListener('click', () => {
        const url = window.location.origin + window.location.pathname + '?room=' + encodeURIComponent(roomName);
        navigator.clipboard?.writeText(url).then(()=> {
          alert('Link copied:\n' + url);
        }).catch(()=> alert('Could not copy. Here is the link:\n' + url));
      });

      // If someone loads with ?room=NAME we will use that room instead (optional convenience)
      const urlParams = new URLSearchParams(window.location.search);
      const paramRoom = urlParams.get('room');
      const finalRoom = paramRoom ? paramRoom : roomName;

      // Preferred constraints to try to get the back camera on mobiles
      const preferredConstraints = { audio: true, video: { facingMode: { ideal: "environment" } } };

      // main init
      async function init() {
        // try to get permission + preferred camera first (helps reveal device labels)
        let chosenVideoDeviceId = null;
        try {
          const stream = await navigator.mediaDevices.getUserMedia(preferredConstraints);
          // If stream available, try to extract deviceId from video track settings
          const vTrack = stream.getVideoTracks()[0];
          if (vTrack) {
            const settings = vTrack.getSettings();
            if (settings && settings.deviceId) chosenVideoDeviceId = settings.deviceId;
          }
          // stop the temporary tracks so Jitsi can take camera
          stream.getTracks().forEach(t => t.stop());
        } catch (err) {
          // permission denied or no back camera — we'll fall back to letting Jitsi choose default
          console.warn('Initial getUserMedia failed or denied:', err && err.name ? err.name : err);
        }

        // If deviceId not found yet, try to enumerate devices and pick one with 'rear' hints
        if (!chosenVideoDeviceId && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoInputs = devices.filter(d => d.kind === 'videoinput');
            // try to find labels with environment/back/rear keywords
            const heur = ['back', 'rear', 'environment', 'kamera', 'cam 2', 'camera 2'];
            for (const d of videoInputs) {
              const label = (d.label || '').toLowerCase();
              if (heur.some(h => label.includes(h))) {
                chosenVideoDeviceId = d.deviceId;
                break;
              }
            }
            // fallback to first videoinput if any
            if (!chosenVideoDeviceId && videoInputs.length) chosenVideoDeviceId = videoInputs[0].deviceId;
          } catch (e) {
            console.warn('enumerateDevices failed:', e);
          }
        }

        // Jitsi options
        const options = {
          roomName: finalRoom,
          width: '100%',
          height: '100%',
          parentNode: container,
          configOverwrite: {
            // skip prejoin so meeting begins immediately
            prejoinPageEnabled: false,
            // ensure audio/video start unmuted if possible
            startWithAudioMuted: false,
            startWithVideoMuted: false,
            // do not start in audio-only mode
            startAudioOnly: false,
            // optional: disable welcome page
            enableWelcomePage: false
          },
          interfaceConfigOverwrite: {
            // minimal toolbar to avoid asking name etc
            DEFAULT_REMOTE_DISPLAY_NAME: 'Participant',
            // you can customize toolbar buttons if desired
          },
          userInfo: {
            displayName: 'Moderator'
          }
        };

        // create the iframe / api
        const api = new JitsiMeetExternalAPI(domain, options);

        // When joined, try to ensure mic & cam are ON and set the chosen device if available
        api.addEventListener('videoConferenceJoined', async () => {
          console.log('Joined conference as:', finalRoom);
          // if we found a preferred video device id, tell Jitsi to use it
          if (chosenVideoDeviceId) {
            try {
              // setVideoInputDevice is supported in many Jitsi builds
              await api.executeCommand('setVideoInputDevice', chosenVideoDeviceId);
              console.log('Requested video deviceId:', chosenVideoDeviceId);
            } catch (e) {
              console.warn('setVideoInputDevice failed:', e);
            }
          } else {
            // another attempt: request facingMode environment for browsers that support setVideoConstraints (best-effort)
            try {
              await api.executeCommand('setVideoConstraints', { facingMode: { ideal: 'environment' } });
            } catch (e) {
              // not supported everywhere
            }
          }

          // Ensure audio/video are unmuted — we set startWithAudioMuted:false, startWithVideoMuted:false above,
          // but call toggle commands only if they are muted (we don't have direct isMuted getter reliably here).
          // Best-effort: try unmute by toggling if needed (this is safe when already unmuted in most builds).
          try {
            // Some Jitsi deployments expose isAudioMuted/isVideoMuted via getAvailableDevices etc — but external API doesn't always.
            // We'll attempt to unmute by executing 'toggleAudio'/'toggleVideo' only if start flags caused them to be muted.
            // NOTE: these are toggles; if you find mic/cam reversed toggle twice.
            // We'll attempt a single toggle to be safe, but rely mainly on the startWithAudioMuted/startWithVideoMuted config.
            // (Commented out to avoid accidental toggles in unknown deployments)
            // api.executeCommand('toggleAudio');
            // api.executeCommand('toggleVideo');
          } catch (err) {
            console.warn('could not toggle audio/video:', err);
          }

          // Optionally set display name again
          try { api.executeCommand('displayName', 'Moderator'); } catch(e){}
        });

        // Error/debug listeners
        api.addEventListener('participantLeft', (evt) => {
          console.log('participantLeft', evt);
        });
        api.addEventListener('participantJoined', (evt) => {
          console.log('participantJoined', evt);
        });

        // If you want to force layout/fullscreen, can add code here
      }

      // Kick off init immediately
      init();
    })();
  </script>
</body>
</html>
